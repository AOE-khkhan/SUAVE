## @ingroup Methods-Power-Battery-Discharge
# datta_discharge.py
# 
# Created:  ### ####, M. Vegh
# Modified: Feb 2016, E. Botero

# ----------------------------------------------------------------------
#  Imports
# ----------------------------------------------------------------------

import numpy as np

# ----------------------------------------------------------------------
#  Datta Discharge
# ----------------------------------------------------------------------

## @ingroup Methods-Power-Battery-Discharge
def datta_discharge(battery,numerics): 
    """models discharge losses based on an empirical correlation
       Based on method taken from Datta and Johnson: 
       
       Assumptions: 
       Constant Peukart coefficient
       
       Source:
       "Requirements for a Hydrogen Powered All-Electric Manned Helicopter" by Datta and Johnson
      
       voltage model from from Chen, M. and Rincon-Mora, G. A., "Accurate Electrical Battery Model Capable of Predicting
       # Runtime and I - V Performance" IEEE Transactions on Energy Conversion, Vol. 21, No. 2, June 2006, pp. 504-511
       
       Inputs:
       battery.
        resistance                      [Ohms]
        max_energy                      [Joules]
        current_energy (to be modified) [Joules]
        inputs.
            current                     [amps]
            power_in                    [Watts]
       
       Outputs:
       battery.
        current energy                  [Joules]
        resistive_losses                [Watts]
        voltage_open_circuit            [Volts]
        voltage_under_load              [Volts]
        
        
    """
    
    I_bat          = battery.inputs.current
    P_bat_in       = battery.inputs.power_in
    R_bat          = battery.resistance
    v_max          = battery.max_voltage
    cell_mass      = battery.mass_properties.mass   
    Cp             = battery.cell.specific_heat_capacity  
    A_cell         = battery.cell.surface_area 
    h              = battery.heat_transfer_coefficient   
    T_ambient      = battery.ambient_temperature       
    T_current      = battery.temperature
    E_current      = battery.current_energy  
    E_max          = battery.max_energy    
    Q_prior        = battery.charge_throughput 
    I              = numerics.time.integrate
    D              = numerics.time.differentiate
    
    #state of charge of the battery
    initial_discharge_state = np.dot(I,P_bat_in) + E_current[0]
    DOD_old =  1 - np.divide(initial_discharge_state,E_max)

    # C rate
    C = np.abs(3600.*P_bat_in/E_max)
    
    # Empirical value for discharge
    DOD_old[DOD_old<-35.] = -35. # Fix DOD_old so it doesn't warn
    
    f = 1-np.exp(-20.*DOD_old)-np.exp(-20.*(1.-DOD_old))
    
    f[f<0.0] = 0.0 # Negative f's don't make sense
    f = np.reshape(f, np.shape(C))
    
    # Model discharge characteristics based on changing resistance
    R          = R_bat*(1.+np.multiply(C,f))
    R[R==R_bat] = 0.  #when battery isn't being called
    
    # Heat power generated by each cell
    P_heat = (I_bat**2.)*R
    
    # Power going into the battery accounting for resistance losses
    P = P_bat_in - np.abs(P_heat) 
    
    # Net heat load 
    P_net  = P_heat - h*A_cell*(T_current[0] - T_ambient)
    
    # Cell temperature rise 
    dT_dt     = P_net/(cell_mass*Cp)
    T_current = T_current[0] + np.dot(I,dT_dt)
    
    ebat = np.dot(I,P)
    ebat = np.reshape(ebat,np.shape(E_current)) #make sure it's consistent
    
    # Add this to the current state
    if np.isnan(ebat).any():
        ebat=np.ones_like(ebat)*np.max(ebat)
        if np.isnan(ebat.any()): #all nans; handle this instance
            ebat=np.zeros_like(ebat)
            
    E_current = ebat + E_current[0]
    
    SOC_new = np.divide(E_current,E_max)
    DOD_new = 1 - SOC_new
     
    # determine new charge throughput  
    Q_current = np.dot(I,I_bat)
    Q_total   = Q_prior + Q_current/3600    
            
    # A voltage model from Chen, M. and Rincon-Mora, G. A., "Accurate Electrical Battery Model Capable of Predicting
    # Runtime and I - V Performance" IEEE Transactions on Energy Conversion, Vol. 21, No. 2, June 2006, pp. 504-511
    v_normalized         = (-1.031*np.exp(-35.*SOC_new) + 3.685 + 0.2156*SOC_new - 0.1178*(SOC_new**2.) + 0.3201*(SOC_new**3.))/4.1
    voltage_open_circuit = v_normalized * v_max
    
    # Voltage under load:
    voltage_under_load   = voltage_open_circuit  - I_bat*R
        
    # Pack outputs
    battery.current_energy          = E_current
    battery.resistive_losses        = P_heat
    battery.cell_temperature        = T_current
    battery.state_of_charge         = SOC_new 
    battery.depth_of_discharge      = DOD_new
    battery.charge_throughput       = Q_total
    battery.voltage_open_circuit    = voltage_open_circuit
    battery.voltage_under_load      = voltage_under_load
    battery.current                 = I_bat
    
    return
